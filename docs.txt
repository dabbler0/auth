PYTHON LIBRARY

<conn> initDB(<string> filename)
  Opens a connection to the database at path <filename> and creates a users database there if it doesn't exist

<dict> generateKey(<conn> conn, <string> uname, <int> A)
  Generates a session key given a username and a client A. Will return
  {
    "M": <int>, #The hash that we expect the client to send for verification
    "K": <string>, #The session key itself (32 characters)
    "encryptor": <AES>, #An AES encryptor instance for message encryption
    "B": <int> #The B value that was generated, for the record
  }

<string> encrypt(<AES> encryptor, <string> message)
  Returns a JSON object containing
  {
    "ciphertext":<string>, #The AES-encrypted text
    "checksum":<string> #An md5 checksum of the plaintext string
  }

<string or None> decrypt(<AES> encryptor, <string> json_message)
  Takes something as generated by encrypt and returns either
    - The plaintext string, if the checksum and the plaintext match up
    - None, otherwise

JAVASCRIPT LIBRARY

<obj> generateA()
  Generates a random (a) and (A) value, returning an object containing
  {
    a: (a),
    A: (A)
  }

<obj> generateKey(<BigInt> salt, <BigInt> B, <obj> adat)
  Generates a session key given the salt, server B-value, and A/a value generated by generateA. Returns an object with
  {
    K: <CryptoJS.enc> //A key for CryptoJS to use in AES encryption/decryption
    M: <BigInt> //The verification hash to send to the server
    R: <BigInt> //The hash that we expect the server to send back to us
  }

<string> encrypt(<CryptoJS.enc> key, <string> message)
  Encrypts a message with a checksum as in the Python function

<string> decrypt(<CryptoJS.enc> key, <string (json)> message)
  Decrypts a message as generated by encrypt()
